% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cas_extract_html.R
\name{cas_extract_html}
\alias{cas_extract_html}
\title{Facilitates extraction of contents from an html file}
\usage{
cas_extract_html(
  html_document,
  container = NULL,
  container_class = NULL,
  container_id = NULL,
  container_name = NULL,
  container_property = NULL,
  container_itemprop = NULL,
  container_instance = NULL,
  attribute = NULL,
  sub_element = NULL,
  no_children = NULL,
  trim = TRUE,
  squish = FALSE,
  no_match = "",
  exclude_CSSpath = NULL,
  exclude_Xpath = NULL,
  custom_Xpath = NULL,
  custom_CSSpath = NULL,
  keep_everything = FALSE,
  extract_text = TRUE,
  as_character = TRUE
)
}
\arguments{
\item{html_document}{An html document parsed with \code{xml2::read_html()} or
\code{rvest::read_html()}.}

\item{container}{Defaults to NULL. Type of html container from where links
are to be extracted, such as "div", "ul", and others. Either
\code{container_class} or \code{container_id} must also be provided.}

\item{container_class}{Defaults to NULL. If provided, also \code{container} must
be given (and \code{container_id} must be NULL). Only text found inside the
provided combination of container/class will be extracted.}

\item{container_id}{Defaults to NULL. If provided, also \code{container} must be
given (and \code{container_id} must be NULL). Only text found inside the
provided combination of container/class will be extracted.}

\item{container_itemprop}{Defaults to NULL. If provided, also \code{container}
must be given (and \code{container_id} and \code{container_class} must be NULL or
will be silently ignored). Only text found inside the provided combination
of container/itemprop will be extracted.}

\item{container_instance}{Defaults to NULL. If given, it must be an integer.
If a given combination is found more than once in the same page, the
relevant occurrence is kept. Use with caution, as not all pages always
include the same number of elements of the same class/with the same id.}

\item{attribute}{Defaults to NULL. If given, type of attribute to extract.
Typically used in combination with container, as in
\code{cas_extract_html(container = "time", attribute = "datetime")}.}

\item{sub_element}{Defaults to NULL. If provided, also \code{container} must be
given. Only text within elements of given type under the chosen combination
of container/containerClass will be extracted. When given, it will
tipically be "p", to extract all p elements inside the selected div.}

\item{no_children}{Defaults to FALSE, i.e. by default all subelements of the
selected combination (e.g. div with given class) are extracted. If TRUE,
only text found under the given combination (but not its subelements) will
be extracted. Corresponds to the xpath string \verb{/node()[not(self::div)]}.}

\item{trim}{Defaults to TRUE. If TRUE, applies \code{stringr::str_trim()} to
output, removing whitespace from start and end of string.}

\item{squish}{Defaults to FALSE. If TRUE, applies \code{stringr::str_squish()} to
output, removing whitespace from start and end of string, and replacing
any whitespace (including new lines) with a single space.}

\item{no_match}{Defaults to "". A common alternative would be NA. Value to
return when the given container, selector or element is not found.}

\item{exclude_CSSpath}{Defaults to NULL. To remove script, for example, use
\code{script}, which is transformed to \verb{:not(script)}. May cause issues, use
with caution.}

\item{exclude_Xpath}{Defaults to NULL. A common pattern when extracting text
would be \verb{//script|//iframe|//img|//style}, as it is assumed that these
containers (javascript contents, iframes, css blocks, and images) are most
likely undesirable when extracting text. Customise as needed. For example,
if besides the above you also want to remove a \code{div} of class
\code{related-articles}, you may use
\verb{//script|//iframe|//img|//div[@class='related-articles']}Be careful when
using \code{exclude_Xpath} as the relevant Xpath is removed from the original
objext passed to \code{cas_extract_html()}. To be clear, the input object is
changed, and, for example, if used once in one of the extractors these
containers won't be available to other extractors.}

\item{custom_Xpath}{Defaults to NULL. If given, all other parameters are
ignored and given Xpath used instead.}

\item{custom_CSSpath}{Defaults to NULL. If given, all other parameters are
ignored and given CSSpath used instead.}

\item{keep_everything}{Defaults to FALSE. If TRUE, all text included in the
page is returned as a single string.}

\item{extract_text}{Defaults to TRUE. If TRUE, text is extracted.}

\item{as_character}{Defaults to TRUE. If FALSE, and if \code{extract_text} is set
to FALSE, then an \code{xml_nodeset} object is returned.}
}
\value{
A character vector of length one.
}
\description{
Facilitates extraction of contents from an html file
}
\examples{
\dontrun{
if (interactive()) {
  url <- "https://example.com"
  html_document <- rvest::read_html(x = url)

  # example for a tag that looks like:
  # <meta name="twitter:title" content="Example title" />

  cas_extract_html(
    html_document = html_document,
    container = "meta",
    container_name = "twitter:title",
    attribute = "content"
  )


  # example for a tag that looks like:
  # <meta name="keywords" content="various;keywords;">
  cas_extract_html(
    html_document = html_document,
    container = "meta",
    container_name = "keywords",
    attribute = "content"
  )

  # example for a tag that looks like:
  # <meta property="article:published_time" content="2016-10-29T13:09+03:00"/>
  cas_extract_html(
    html_document = html_document,
    container = "meta",
    container_property = "article:published_time",
    attribute = "content"
  )
}
}
}
